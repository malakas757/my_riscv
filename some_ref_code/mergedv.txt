/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  dcache.sv  (write through)                          //
//                                                                     //
//  Description :  data cache;                                         // 
/////////////////////////////////////////////////////////////////////////

`ifndef __DCACHE_IN_V__
`define __DCACHE_IN_V__
`timescale 1ns/100ps
`include"sys_defs.svh "

module dcahce_in (
    input   logic                   clock,
    input   logic                   reset,

    input   logic                   read_en,
    input   logic                   [`XLEN-1:0] read_addr,

    input   logic                   write_en,
    input   logic                   [`XLEN-1:0] write_addr,
    input   MEM_SIZE		        write_mem_size, 
    input   logic [`XLEN-1:0]       write_data_in,

    input   logic                   mem_en,
    input   logic [`XLEN-1:0]       mem_addr,
    input   logic [63:0]            mem_data_in,

    output  logic                   read_hit,
    output  logic [63:0]            read_data_out,

    output  EXAMPLE_CACHE_BLOCK     write_data_out,
    output  logic                   write_hit
    );

    //Inside Dcache
    DCACHE_ENTRY_NEW    [`D_CACHE_LINES-1:0]      dcache_entries;

    logic [$clog2(`D_CACHE_LINES)-1:0]    load_idx, store_idx, mem_idx;
    logic [12 - $clog2(`D_CACHE_LINES):0] load_tag, store_tag, mem_tag;

    assign {load_tag, load_idx} = read_addr[15:3];
    assign {store_tag, store_idx} = write_addr[15:3];
    assign {mem_tag, mem_idx} = mem_addr[15:3];

    // assign read_hit  = read_en && ((dcache_entries[load_idx].valid && dcache_entries[load_idx].tag == load_tag)
    //                                 || (write_hit && load_idx == store_idx && load_tag == store_tag)) ;
    assign write_hit = dcache_entries[store_idx].valid && dcache_entries[store_idx].tag == store_tag && write_en &&
                       (~mem_en || (store_idx != mem_idx));
    // assign read_data_out = (read_en && dcache_entries[load_idx].valid && dcache_entries[load_idx].tag == load_tag) ? dcache_entries[load_idx].data : 
    //                        (read_en && write_hit && load_idx == store_idx && load_tag == store_tag) ? write_data_out: 64'b0;

    always_comb begin
        read_hit = 1'b0;
        read_data_out = 64'b0;
        if (read_en) begin
            if (dcache_entries[load_idx].valid && dcache_entries[load_idx].tag == load_tag) begin
                read_hit = 1'b1;
                read_data_out = dcache_entries[load_idx].data;
            end else if (mem_en && mem_idx == load_idx && load_tag == mem_tag) begin
                read_hit = 1'b1;
                read_data_out = mem_data_in;
            end else if (write_hit && store_idx == load_idx && load_tag == store_tag) begin
                read_hit = 1'b1;
                read_data_out = write_data_out;
            end
        end
    end

    //Write
    always_comb begin
        write_data_out = 64'b0;
        if (write_hit) begin
            write_data_out = dcache_entries[store_idx].data;
            casez (write_mem_size)
                BYTE: write_data_out.byte_level[write_addr[2:0]]    = write_data_in[7:0];
                HALF: write_data_out.half_level[write_addr[2:1]]    = write_data_in[15:0];
                WORD: write_data_out.word_level[write_addr[2]]      = write_data_in[31:0];
            endcase
        end
    end

   
    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            dcache_entries <= `SD 0;
        end else begin
            if (mem_en) begin
                dcache_entries[mem_idx].data <= `SD mem_data_in;
                dcache_entries[mem_idx].valid <= `SD 1'b1;
                dcache_entries[mem_idx].tag   <= `SD mem_tag;
            end
            if (write_hit) begin
                casez (write_mem_size)
                    BYTE: dcache_entries[store_idx].data.byte_level[write_addr[2:0]]    <= `SD write_data_in[7:0];
                    HALF: dcache_entries[store_idx].data.half_level[write_addr[2:1]]    <= `SD write_data_in[15:0];
                    WORD: dcache_entries[store_idx].data.word_level[write_addr[2]]      <= `SD write_data_in[31:0];
                endcase
                dcache_entries[store_idx].valid     <= `SD 1'b1;
                dcache_entries[store_idx].tag       <= `SD store_tag;
            end 
        end
        
    end

    `ifdef DEBUG
    logic [31:0] cycle_count;
    DCACHE_ENTRY_NEW cur_entry;
    // synopsys sync_set_reset "reset"
    always_ff @(negedge clock) begin
        if(reset) begin
            cycle_count = 0;
        end else begin
            for(int i = 0; i < `CACHE_LINES; i += 1) begin
                cur_entry = dcache_entries[i];
                $display("DEBUG %4d: dcache[%2d] = 0x%x, valid[%2d]=%b", cycle_count, i, cur_entry.data.double_level, i, cur_entry.valid);
            end
            cycle_count = cycle_count + 1;
        end
    end
    `endif

endmodule
`endif/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  dcache.sv  (write through)                          //
//                                                                     //
//  Description :  data cache;                                         // 
/////////////////////////////////////////////////////////////////////////

`ifndef __DCACHE_CTRL_V__
`define __DCACHE_CTRL_V__

`timescale 1ns/100ps



module dcache_control (
    input logic clock,
    input logic reset,
    input logic chosen2Mem,  

    //From Dmem
    input logic                                   Dmem2proc_valid,
    input logic [3:0]                             Dmem2proc_response,
    input logic [63:0]                            Dmem2proc_data,
    input logic [3:0]                             Dmem2proc_tag,

    //From LSQ
    input logic load_en,
    input logic [`XLEN-1:0] load_addr,
    input logic store_en,
    input logic [`XLEN-1:0] store_addr,
    //input logic [63:0] store_data,
   

    //From Dcache
    input logic load_hit_in,
    input logic store_hit_in,
    input logic [63:0] store_data_in,

    //OUTPUT

    //TO Dcache
    output   logic mem_en,
    output   logic [`XLEN-1:0] mem_addr_out,
    output   logic [63:0]      mem_data_out,
    
    //TO LSQ
    output logic store_complete,
    output logic halt_valid,

    //TO Dmem
    output logic                            proc2Dmem_valid,
    output logic [63:0]                     proc2Dmem_data,
    output logic [1:0]                      proc2Dmem_command,
    output logic [`XLEN-1:0]                proc2Dmem_addr
);

    MISS_ENTRY_NEW      [`MISS_LINES-1:0]       mshr_entries, next_mshr_entries;

    logic temp_valid, request_sent;



    always_comb begin

        //Initialize
        next_mshr_entries   = mshr_entries;
        store_complete      = 1'b0;
        mem_en              = 1'b0;
        halt_valid          = 1'b1;
        
        //Check output from Dmem
        if (Dmem2proc_valid) begin
            temp_valid = 1'b0;
            for (int i = 0; i < `MISS_LINES; i += 1) begin
                if (~temp_valid && Dmem2proc_tag != 0 && mshr_entries[i].valid && mshr_entries[i].sent && mshr_entries[i].tag == Dmem2proc_tag) begin
                    mem_en = 1'b1;
                    temp_valid = 1'b1;
                    mem_addr_out = mshr_entries[i].addr;
                    mem_data_out = Dmem2proc_data;
                    next_mshr_entries[i] = 0;
                end
            end
        end

        //Update MSHR
        if (load_en && ~load_hit_in) begin
            temp_valid = 1'b0;
            for (int i = 0; i < `MISS_LINES; i += 1) begin
                if (~temp_valid && next_mshr_entries[i].valid && next_mshr_entries[i].addr[`XLEN-1:3] == load_addr[`XLEN-1:3]) begin
                    temp_valid = 1'b1;
                end
            end

            if (~temp_valid) begin
                for (int i = 0; i < `MISS_LINES; i += 1) begin
                    if (~temp_valid && ~next_mshr_entries[i].valid && ~next_mshr_entries[i].sent) begin
                        temp_valid = 1'b1;
                        next_mshr_entries[i].valid = 1'b1;
                        next_mshr_entries[i].sent  = 1'b0;
                        next_mshr_entries[i].addr = {load_addr[`XLEN-1:3],3'b0};
                    end
                end
            end
            
        end

        if (store_en && ~store_hit_in) begin //Load block before store
            temp_valid      = 1'b0;
            halt_valid      = 1'b0;
            for (int i = 0; i < `MISS_LINES; i += 1) begin
                if (~temp_valid && next_mshr_entries[i].valid && next_mshr_entries[i].addr[`XLEN-1:3] == store_addr[`XLEN-1:3]) begin
                    temp_valid = 1'b1;
                end
            end
            if (~temp_valid) begin
                for (int i = 0; i < `MISS_LINES; i += 1) begin
                    if (~temp_valid && ~next_mshr_entries[i].valid && ~next_mshr_entries[i].sent) begin
                        temp_valid = 1'b1;
                        next_mshr_entries[i].valid = 1'b1;
                        next_mshr_entries[i].sent  = 1'b0;
                        next_mshr_entries[i].addr = {store_addr[`XLEN-1:3], 3'b0};
                    end
                end
            end
            
        end

        //Send request to Dmem
        proc2Dmem_valid     = 1'b0;
        proc2Dmem_data      = 64'b0;
        proc2Dmem_command   = BUS_NONE;
        proc2Dmem_addr      = `XLEN'b0;

        if (store_hit_in && store_en) begin
            proc2Dmem_valid     = 1'b1;
            proc2Dmem_data      = store_data_in;
            proc2Dmem_command   = BUS_STORE;
            proc2Dmem_addr      = {store_addr[`XLEN-1:3], 3'b0};
            store_complete      = (Dmem2proc_response != 4'b0) && chosen2Mem;
            halt_valid          = (Dmem2proc_response != 4'b0) && chosen2Mem;
            request_sent        = 1'b1;
            for (int i = 0; i < `MISS_LINES; i += 1) begin
                if (next_mshr_entries[i].valid && next_mshr_entries[i].addr[`XLEN-1:3] == proc2Dmem_addr[`XLEN-1:3]) begin
                    next_mshr_entries[i].valid = 1'b0;
                    next_mshr_entries[i].sent = 1'b0;
                end
            end
        end else begin
            request_sent = 1'b0;
            for (int i = 0; i < `MISS_LINES; i += 1) begin
                if (~request_sent && next_mshr_entries[i].valid && ~next_mshr_entries[i].sent) begin
                    proc2Dmem_valid     = 1'b1;
                    proc2Dmem_data      = 64'b0;
                    proc2Dmem_command   = BUS_LOAD;
                    proc2Dmem_addr      = next_mshr_entries[i].addr;
                    next_mshr_entries[i].tag = Dmem2proc_response;
                    next_mshr_entries[i].sent = (Dmem2proc_response != 4'b0) && chosen2Mem;
                    request_sent = 1'b1;
                end
            end
        end

    end

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            mshr_entries <= `SD 0;
        end else begin
            mshr_entries <= `SD next_mshr_entries;
        end
    end
    `ifdef DEBUG
    logic [31:0] cycle_count;
    MISS_ENTRY cur_entry;
    // synopsys sync_set_reset "reset"
    always_ff @(negedge clock) begin
        if(reset) begin
            cycle_count = 0;
        end else begin
            for(int i = 0; i < `MISS_LINES; i += 1) begin
                cur_entry = mshr_entries[i];
                $display("DEBUG %4d: MSHR[%2d] = %p", cycle_count, i, cur_entry);
            end
            $display("proc2Dmemcommand = %b", proc2Dmem_command);
            cycle_count = cycle_count + 1;
        end
    end
    `endif


endmodule
`endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  dcache.sv  (write through)                          //
//                                                                     //
//  Description :  data cache;                                         // 
/////////////////////////////////////////////////////////////////////////

`ifndef __DCACHE_V__
`define __DCACHE_V__
`define DEBUG_D
`include"sys_defs.svh"
`timescale 1ns/100ps

module dcache (
    input                                   clock,
    input                                   reset,
    // From Pipeline
    input                                   chosen2Mem,

    // From Dmem
    input                                   Dmem2proc_valid,
    input [3:0]                             Dmem2proc_response,
    input [63:0]                            Dmem2proc_data,
    input [3:0]                             Dmem2proc_tag,

    // To Dmem
    output logic                            proc2Dmem_valid,
    output logic [63:0]                     proc2Dmem_data,
    output logic [1:0]                      proc2Dmem_command,
    output logic [`XLEN-1:0]                proc2Dmem_addr,

    // From LSQ
    input LSQ_LOAD_DCACHE_PACKET            lsq_load_dc,
    input LSQ_STORE_DCACHE_PACKET           lsq_store_dc,

    // To LSQ
    output DCACHE_LOAD_LSQ_PACKET           dc_load_lsq,
    output DCACHE_STORE_LSQ_PACKET          dc_store_lsq
);
    logic load_hit, store_hit, mem_en;
    logic [`XLEN-1:0] mem_addr;
    logic [63:0] mem_data;
    EXAMPLE_CACHE_BLOCK store_data_in, read_data_out;

    `ifdef DEBUG_D
        logic [31:0] cycle_count;
        always_ff @(negedge clock) begin
            if (reset) begin
                cycle_count = 0;
            end else begin
                $display("DEBUG %4d: LOAD_DC=%p, STORE_DC=%p", cycle_count, lsq_load_dc, lsq_store_dc);
                $display("DEBUG %4d: DC_LOAD=%p, DC_STORE=%p", cycle_count, dc_load_lsq, dc_store_lsq);
                cycle_count += 1;
            end    
        end
    `endif

    dcache_control dcache_control_0(
        .clock(clock),
        .reset(reset),  
        .chosen2Mem(chosen2Mem),

        .Dmem2proc_valid(Dmem2proc_valid),
        .Dmem2proc_response(Dmem2proc_response),
        .Dmem2proc_data(Dmem2proc_data),
        .Dmem2proc_tag(Dmem2proc_tag),
 
        //From LSQ
        .load_en(lsq_load_dc.valid && (~lsq_store_dc.halt || ~lsq_store_dc.valid)),
        //.load_en(lsq_load_dc.valid),
        .load_addr(lsq_load_dc.addr),
        .store_en(lsq_store_dc.valid && ~lsq_store_dc.halt),
        //.store_en(lsq_store_dc.valid),
        .store_addr(lsq_store_dc.addr),


        //From Dcache
        .load_hit_in(load_hit),
        .store_hit_in(store_hit),
        .store_data_in(store_data_in),

        //OUTPUT
        
        //TO Dcache
        .mem_en(mem_en),
        .mem_addr_out(mem_addr),
        .mem_data_out(mem_data),
    
        //TO LSQ
        .store_complete(dc_store_lsq.valid),
        .halt_valid(dc_store_lsq.halt_valid),

        //TO Dmem
        .proc2Dmem_valid(proc2Dmem_valid),
        .proc2Dmem_data(proc2Dmem_data),
        .proc2Dmem_command(proc2Dmem_command),
        .proc2Dmem_addr(proc2Dmem_addr)
        );

     dcahce_in dcache_in_0(
        .clock(clock),
        .reset(reset),

        .read_en(lsq_load_dc.valid && (~lsq_store_dc.halt || ~lsq_store_dc.valid)),
        .read_addr(lsq_load_dc.addr),
        .write_en(lsq_store_dc.valid && ~lsq_store_dc.halt),
        .write_addr(lsq_store_dc.addr),
        .write_mem_size(lsq_store_dc.mem_size),
        .write_data_in(lsq_store_dc.value),

        .mem_en(mem_en),
        .mem_addr(mem_addr),
        .mem_data_in(mem_data),

        .read_hit(dc_load_lsq.valid),
        .read_data_out(read_data_out),
        .write_data_out(store_data_in),
        .write_hit(store_hit));

    always_comb begin
        dc_load_lsq.value = 32'b0;
        if (dc_load_lsq.valid) begin
            casez (lsq_load_dc.mem_size)
                BYTE: dc_load_lsq.value = {24'b0,   read_data_out.byte_level[lsq_load_dc.addr[2:0]]};
                HALF: dc_load_lsq.value = {16'b0,   read_data_out.half_level[lsq_load_dc.addr[2:1]]};
                WORD: dc_load_lsq.value =           read_data_out.word_level[lsq_load_dc.addr[2]];
            endcase
        end 
    end

    

endmodule
`endif/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  br_predictor.sv                                     //
//                                                                     //
//  Description :  branch predictor                                    // 
/////////////////////////////////////////////////////////////////////////

//`define DEBUG
`ifndef __BR_PREDICTOR_V__
`define __BR_PREDICTOR_V__
`include"sys_defs.svh"
`timescale 1ns/100ps

`define PHT_SIZE 16
`define BHR_SIZE $clog2(`PHT_SIZE)

module dirp_gshare (
    input clock,
    input reset,

    //Branch History
    input branch_result_valid,
    input branch_result, //1 for taken, 0 for not taken
    input [`BHR_SIZE-1:0] ex_idx, //the previous idx to update PHT

    //Branch Prediction
    input is_branch,
    input [`XLEN-1:0] targetPC_in,

    output logic branch_taken,
    output logic [`DIRP_IDX_LEN-1:0] dirp_tag
);
    //Global BHR
    logic [`BHR_SIZE-1:0] BHR_g;

    //Global PHT
    logic [`PHT_SIZE-1:0][1:0] PHT_g, PHT_g_next;
    logic [`BHR_SIZE-1:0] idx;

    assign branch_taken = (~is_branch || PHT_g[dirp_tag] == 2'b00 || PHT_g[dirp_tag] == 2'b01)? 1'b0: 1'b1; 
    assign dirp_tag = (is_branch) ? BHR_g ^ targetPC_in[`BHR_SIZE+1:2] : 5'b0;

    always_comb begin
        PHT_g_next = PHT_g;
        if (branch_result_valid) begin
            case(PHT_g[ex_idx])
            2'b00: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b01 : 2'b00;
            end
            2'b01: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b10 : 2'b00;
            end
            2'b10: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b11 : 2'b01;
            end
            2'b11: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b11 : 2'b10;
            end
            endcase
        end

    end                    
    

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            BHR_g <= `SD 0;
            PHT_g <= `SD '{`PHT_SIZE{2'b10}};
        end else begin
            PHT_g <= `SD PHT_g_next;
            if (branch_result_valid) begin
                BHR_g <= `SD {BHR_g[`BHR_SIZE-2:0],branch_result};
            end
        end
    end

    `ifdef DEBUG
        logic [31:0] cycle_count;
        // synopsys sync_set_reset "reset"
        always_ff @(negedge clock) begin
            if (reset) begin
                cycle_count = 0;
            end else begin
                $display("DEBUG %4d: BHR_g = %b", cycle_count, BHR_g);
                $display("DEBUG %4d: dirp_tag = %b", cycle_count, dirp_tag);
                for (int i = 0; i < `PHT_SIZE; i += 1) begin
                    $display("DEBUG %4d: PHT[%4d]=%b", cycle_count, i, PHT_g[i]);
                end
                cycle_count += 1;
            end  
        end
   `endif

endmodule

`endif
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  br_predictor.sv                                     //
//                                                                     //
//  Description :  branch predictor                                    // 
/////////////////////////////////////////////////////////////////////////

//`define DEBUG
`ifndef __BR_PREDICTOR_HYBRID_V__
`define __BR_PREDICTOR_HYBRID_V__

`timescale 1ns/100ps

`define PHT_SIZE 32
`define BHT_SIZE 32
`define BHR_SIZE $clog2(`PHT_SIZE)

module dirp_hybrid (
    input clock,
    input reset,

    //Branch History
    input branch_result_valid,
    input branch_result, //1 for taken, 0 for not taken
    input [2*`BHR_SIZE+$clog2(`BHT_SIZE)+1:0] ex_idx, //the previous idx to update PHT

    //Branch Prediction
    input is_branch,
    input [`XLEN-1:0] targetPC_in,

    output logic branch_taken,
    output logic [2*`BHR_SIZE+$clog2(`BHT_SIZE)+1:0] dirp_tag
);
    //Local BHT
    //logic [`BHT_SIZE-1:0][`BHR_SIZE-1:0] BHT_p;
    logic [`BHT_SIZE-1:0] PHT_count;
    logic [`BHR_SIZE-1:0] BHR_g, pag_idx, gshare_idx, pag_idx_out, gshare_idx_out, count_idx;
    

    //Global PHT
    logic [`PHT_SIZE-1:0][1:0] PHT_pag, PHT_pag_next, PHT_gshare, PHT_gshare_next;
    

    assign branch_taken = (is_branch && (PHT_count[pag_idx_out] == 2'b00 || PHT_count[pag_idx_out] == 2'b01)) ? (PHT_pag[pag_idx_out] == 2'b10 || PHT_pag[pag_idx_out] == 2'b11 ):
                           is_branch ? (PHT_pag[gshare_idx_out] == 2'b10 || PHT_pag[gshare_idx_out] == 2'b11 ): 1'b0;
    //(~is_branch || PHT_pag[dirp_tag] == 2'b00 || PHT_pag[dirp_tag] == 2'b01)? 1'b0: 1'b1; 
    assign dirp_tag = {targetPC_in[$clog2(`BHT_SIZE)+1:2],gshare_idx_out,pag_idx_out,PHT_gshare[gshare_idx_out],PHT_pag[pag_idx_out]};
    assign pag_idx = ex_idx[`BHR_SIZE+1:2];
    assign gshare_idx = ex_idx[2*`BHR_SIZE+1:`BHR_SIZE+2];
    assign count_idx = ex_idx[2*`BHR_SIZE+$clog2(`BHT_SIZE)+1:2*`BHR_SIZE+2];

    assign pag_idx_out = targetPC_in[`BHR_SIZE+1:2];
    // assign gshare_idx_out = BHR_g ^ targetPC_in[`BHR_SIZE+1:2]; 
    assign gshare_idx_out =  BHR_g;

    //local 
    always_comb begin
        PHT_pag_next = PHT_pag;
        if (branch_result_valid) begin
            case(PHT_pag[pag_idx])
            2'b00: begin
                PHT_pag_next[pag_idx] = (branch_result) ? 2'b01 : 2'b00;
            end
            2'b01: begin
                PHT_pag_next[pag_idx] = (branch_result) ? 2'b10 : 2'b00;
            end
            2'b10: begin
                PHT_pag_next[pag_idx] = (branch_result) ? 2'b11 : 2'b01;
            end
            2'b11: begin
                PHT_pag_next[pag_idx] = (branch_result) ? 2'b11 : 2'b10;
            end
            endcase
        end
    end

    //Global
    always_comb begin
        PHT_gshare_next = PHT_gshare;
        if (branch_result_valid) begin
            case(PHT_pag[gshare_idx])
            2'b00: begin
                PHT_gshare_next[gshare_idx] = (branch_result) ? 2'b01 : 2'b00;
            end
            2'b01: begin
                PHT_gshare_next[gshare_idx] = (branch_result) ? 2'b10 : 2'b00;
            end
            2'b10: begin
                PHT_gshare_next[gshare_idx] = (branch_result) ? 2'b11 : 2'b01;
            end
            2'b11: begin
                PHT_gshare_next[gshare_idx] = (branch_result) ? 2'b11 : 2'b10;
            end
            endcase
        end
    end                     
    

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            BHR_g <= `SD 0;
            //BHT_p <= `SD '{`BHT_SIZE{4'b0000}};
            PHT_pag <= `SD '{`PHT_SIZE{2'b10}};
            PHT_gshare <= `SD '{`PHT_SIZE{2'b10}};
            PHT_count <= `SD '{`BHT_SIZE{2'b10}};
        end else begin 
            PHT_pag <= `SD PHT_pag_next;
            PHT_gshare <= `SD PHT_gshare_next;
            if (branch_result_valid) begin
                //BHT_p[targetPC_in[$clog2(`BHT_SIZE)+1:2]] <= `SD {BHT_p[targetPC_in[$clog2(`BHT_SIZE)+1:2]][`BHR_SIZE-2:0],branch_result};
                BHR_g <= `SD {BHR_g[`BHR_SIZE-2:0],branch_result};
                PHT_count[count_idx] <= `SD (branch_result == ex_idx[1] && branch_result != ex_idx[0] && PHT_count[count_idx] != 2'b11) ? PHT_count[count_idx]+1 : 
                                          (branch_result != ex_idx[1] && branch_result == ex_idx[0] && PHT_count[count_idx] != 2'b00) ? PHT_count[count_idx]-1 :
                                           PHT_count[count_idx];
            end
        end
    end

//     `ifdef DEBUG
//         logic [31:0] cycle_count;
//         // synopsys sync_set_reset "reset"
//         always_ff @(negedge clock) begin
//             if (reset) begin
//                 cycle_count = 0;
//             end else begin
//                 $display("DEBUG %4d: BHR_g = %b", cycle_count, BHR_g);
//                 $display("DEBUG %4d: dirp_tag = %b", cycle_count, dirp_tag);
//                 for (int i = 0; i < `PHT_SIZE; i += 1) begin
//                     $display("DEBUG %4d: PHT[%4d]=%b", cycle_count, i, PHT_pag[i]);
//                 end
//                 cycle_count += 1;
//             end  
//         end
//    `endif

endmodule

`endif
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  br_predictor.sv                                     //
//                                                                     //
//  Description :  branch predictor                                    // 
/////////////////////////////////////////////////////////////////////////

//`define DEBUG
`ifndef __BR_PREDICTOR_PAG_V__
`define __BR_PREDICTOR_PAG_V__

`timescale 1ns/100ps

`define PHT_SIZE 16
`define BHT_SIZE 32
`define BHR_SIZE $clog2(`PHT_SIZE)

module dirp_pag (
    input clock,
    input reset,

    //Branch History
    input branch_result_valid,
    input branch_result, //1 for taken, 0 for not taken
    input [`BHR_SIZE-1:0] ex_idx, //the previous idx to update PHT

    //Branch Prediction
    input is_branch,
    input [`XLEN-1:0] targetPC_in,

    output logic branch_taken,
    output logic [`BHR_SIZE-1:0] dirp_tag
);
    //Local BHT
    logic [`BHT_SIZE-1:0][`BHR_SIZE-1:0] BHT_p;
    

    //Global PHT
    logic [`PHT_SIZE-1:0][1:0] PHT_g, PHT_g_next;
    

    assign branch_taken = (~is_branch || PHT_g[dirp_tag] == 2'b00 || PHT_g[dirp_tag] == 2'b01)? 1'b0: 1'b1; 
    assign dirp_tag = BHT_p[targetPC_in[$clog2(`BHT_SIZE)+1:2]];

    always_comb begin
        PHT_g_next = PHT_g;
        if (branch_result_valid) begin
            case(PHT_g[ex_idx])
            2'b00: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b01 : 2'b00;
            end
            2'b01: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b10 : 2'b00;
            end
            2'b10: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b11 : 2'b01;
            end
            2'b11: begin
                PHT_g_next[ex_idx] = (branch_result) ? 2'b11 : 2'b10;
            end
            endcase
        end

    end                    
    

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            BHT_p <= `SD '{`BHT_SIZE{4'b0000}};
            PHT_g <= `SD '{`PHT_SIZE{2'b10}};
        end else begin
            PHT_g <= `SD PHT_g_next;
            if (branch_result_valid) begin
                BHT_p[targetPC_in[$clog2(`BHT_SIZE)+1:2]] <= `SD {BHT_p[targetPC_in[$clog2(`BHT_SIZE)+1:2]][`BHR_SIZE-2:0],branch_result};
            end
        end
    end

//     `ifdef DEBUG
//         logic [31:0] cycle_count;
//         // synopsys sync_set_reset "reset"
//         always_ff @(negedge clock) begin
//             if (reset) begin
//                 cycle_count = 0;
//             end else begin
//                 $display("DEBUG %4d: BHR_g = %b", cycle_count, BHR_g);
//                 $display("DEBUG %4d: dirp_tag = %b", cycle_count, dirp_tag);
//                 for (int i = 0; i < `PHT_SIZE; i += 1) begin
//                     $display("DEBUG %4d: PHT[%4d]=%b", cycle_count, i, PHT_g[i]);
//                 end
//                 cycle_count += 1;
//             end  
//         end
//    `endif

endmodule

`endif
//////////////////////////////////////////////////////////////////////////
//                                                                      //
//   Modulename :  ex_stage.v                                           //
//                                                                      //
//  Description :  instruction execute (EX) stage of the pipeline;      //
//                 given the instruction command code CMD, select the   //
//                 proper input A and B for the ALU, compute the result,// 
//                 and compute the condition for branches, and pass all //
//                 the results down the pipeline. MWB                   // 
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
`ifndef __EX_STAGE_V__
`define __EX_STAGE_V__

`timescale 1ns/100ps

//
// The ALU
//
// given the command code CMD and proper operands A and B, compute the
// result of the instruction
//
// This module is purely combinational
//
module alu(
	input [`XLEN-1:0] opa,
	input [`XLEN-1:0] opb,
	ALU_FUNC     func,

	output logic [`XLEN-1:0] result
);
	wire signed [`XLEN-1:0] signed_opa, signed_opb;
	wire signed [2*`XLEN-1:0] signed_mul, mixed_mul;
	wire        [2*`XLEN-1:0] unsigned_mul;
	assign signed_opa = opa;
	assign signed_opb = opb;
	assign signed_mul = signed_opa * signed_opb;
	assign unsigned_mul = opa * opb;
	assign mixed_mul = signed_opa * opb;

	always_comb begin
		case (func)
			ALU_ADD:      result = opa + opb;
			ALU_SUB:      result = opa - opb;
			ALU_AND:      result = opa & opb;
			ALU_SLT:      result = signed_opa < signed_opb;
			ALU_SLTU:     result = opa < opb;
			ALU_OR:       result = opa | opb;
			ALU_XOR:      result = opa ^ opb;
			ALU_SRL:      result = opa >> opb[4:0];
			ALU_SLL:      result = opa << opb[4:0];
			ALU_SRA:      result = signed_opa >>> opb[4:0]; // arithmetic from logical shift
			ALU_MUL:      result = signed_mul[`XLEN-1:0];
			ALU_MULH:     result = signed_mul[2*`XLEN-1:`XLEN];
			ALU_MULHSU:   result = mixed_mul[2*`XLEN-1:`XLEN];
			ALU_MULHU:    result = unsigned_mul[2*`XLEN-1:`XLEN];

			default:      result = `XLEN'hfacebeec;  // here to prevent latches
		endcase
	end
endmodule // alu

//
// BrCond module
//
// Given the instruction code, compute the proper condition for the
// instruction; for branches this condition will indicate whether the
// target is taken.
//
// This module is purely combinational
//
module brcond(// Inputs
	input [`XLEN-1:0] rs1,    // Value to check against condition
	input [`XLEN-1:0] rs2,
	input  [2:0] func,  // Specifies which condition to check

	output logic cond    // 0/1 condition result (False/True)
);

	logic signed [`XLEN-1:0] signed_rs1, signed_rs2;
	assign signed_rs1 = rs1;
	assign signed_rs2 = rs2;
	always_comb begin
		cond = 0;
		case (func)
			3'b000: cond = signed_rs1 == signed_rs2;  // BEQ
			3'b001: cond = signed_rs1 != signed_rs2;  // BNE
			3'b100: cond = signed_rs1 < signed_rs2;   // BLT
			3'b101: cond = signed_rs1 >= signed_rs2;  // BGE
			3'b110: cond = rs1 < rs2;                 // BLTU
			3'b111: cond = rs1 >= rs2;                // BGEU
		endcase
	end
	
endmodule // brcond


module ex_stage(
	input clock,               // system clock
	input reset,               // system reset
	input ID_EX_PACKET   id_ex_packet_in,
	output EX_MEM_PACKET ex_packet_out
);
	// Pass-throughs_ex_packet_in.inst);
		endcase n.halt;
	assign ex_packet_out.illegal = id_ex_packet_in.illegal;
	assign ex_packet_out.csr_op = id_ex_packet_in.csr_op;
	assign ex_packet_out.valid = id_ex_packet_in.valid;
	assign ex_packet_out.mem_size = id_ex_packet_in.inst.r.funct3;

	logic [`XLEN-1:0] opa_mux_out, opb_mux_out;
	logic brcond_result;
	//
	// ALU opA mux
	//
	always_comb begin
		opa_mux_out = `XLEN'hdeadfbac;
		case (id_ex_packet_in.opa_select)
			OPA_IS_RS1:  opa_mux_out = id_ex_packet_in.rs1_value;
			OPA_IS_NPC:  opa_mux_out = id_ex_packet_in.NPC;
			OPA_IS_PC:   opa_mux_out = id_ex_packet_in.PC;
			OPA_IS_ZERO: opa_mux_out = 0;
		endcase
	end

	 //
	 // ALU opB mux
	 //
	always_comb begin
		// Default value, Set only because the case isnt full.  If you see this
		// value on the output of the mux you have an invalid opb_select
		opb_mux_out = `XLEN'hfacefeed;
		case (id_ex_packet_in.opb_select)
			OPB_IS_RS2:   opb_mux_out = id_ex_packet_in.rs2_value;
			OPB_IS_I_IMM: opb_mux_out = `RV32_signext_Iimm(id_ex_packet_in.inst);
			OPB_IS_S_IMM: opb_mux_out = `RV32_signext_Simm(id_ex_packet_in.inst);
			OPB_IS_B_IMM: opb_mux_out = `RV32_signext_Bimm(id_ex_packet_in.inst);
			OPB_IS_U_IMM: opb_mux_out = `RV32_signext_Uimm(id_ex_packet_in.inst);
			OPB_IS_J_IMM: opb_mux_out = `RV32_signext_Jimm(id_ex_packet_in.inst);
		endcase 
	end

	//
	// instantiate the ALU
	//
	alu alu_0 (// Inputs
		.opa(opa_mux_out),
		.opb(opb_mux_out),
		.func(id_ex_packet_in.alu_func),

		// Output
		.result(ex_packet_out.alu_result)
	);

	 //
	 // instantiate the branch condition tester
	 //
	brcond brcond (// Inputs
		.rs1(id_ex_packet_in.rs1_value), 
		.rs2(id_ex_packet_in.rs2_value),
		.func(id_ex_packet_in.inst.b.funct3), // inst bits to determine check

		// Output
		.cond(brcond_result)
	);

	 // ultimate "take branch" signal:
	 //	unconditional, or conditional and the condition is true
	assign ex_packet_out.take_branch = id_ex_packet_in.uncond_branch
		                          | (id_ex_packet_in.cond_branch & brcond_result);

endmodule // module ex_stage
`endif // __EX_STAGE_V__
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  id_stage.v                                          //
//                                                                     //
//  Description :  instruction decode (ID) stage of the pipeline;      // 
//                 decode the instruction fetch register operands, and // 
//                 compute immediate operand (if applicable)           // 
//                                                                     //
/////////////////////////////////////////////////////////////////////////


`timescale 1ns/100ps


  // Decode an instruction: given instruction bits IR produce the
  // appropriate datapath control signals.
  //
  // This is a *combinational* module (basically a PLA).
  //
module decoder (

	//input [31:0] inst,
	//input valid_inst_in,  // ignore inst when low, outputs will
	                      // reflect noop (except valid_inst)
	//see sys_defs.svh for definition
	input IF_ID_PACKET if_packet,
	
	output ALU_OPA_SELECT opa_select,
	output ALU_OPB_SELECT opb_select,
	output DEST_REG_SEL   dest_reg, // mux selects
	output ALU_FUNC       alu_func,
	output logic rd_mem, wr_mem, cond_branch, uncond_branch,
	output logic csr_op,    // used for CSR operations, we only used this as 
	                        //a cheap way to get the return code out
	output logic halt,      // non-zero on a halt
	output logic illegal,    // non-zero on an illegal instruction
	output logic valid_inst  // for counting valid instructions executed
	                        // and for making the fetch stage die on halts/
	                        // keeping track of when to allow the next
	                        // instruction out of fetch
	                        // 0 for HALT and illegal instructions (die on halt)

);

	INST inst;
	logic valid_inst_in;
	
	assign inst          = if_packet.inst;
	assign valid_inst_in = if_packet.valid;
	assign valid_inst    = valid_inst_in & ~illegal;
	
	always_comb begin
		// default control values:
		// - valid instructions must override these defaults as necessary.
		//	 opa_select, opb_select, and alu_func should be set explicitly.
		// - invalid instructions should clear valid_inst.
		// - These defaults are equivalent to a noop
		// * see sys_defs.vh for the constants used here
		opa_select = OPA_IS_RS1;
		opb_select = OPB_IS_RS2;
		alu_func = ALU_ADD;
		dest_reg = DEST_NONE;
		csr_op = `FALSE;
		rd_mem = `FALSE;
		wr_mem = `FALSE;
		cond_branch = `FALSE;
		uncond_branch = `FALSE;
		halt = `FALSE;
		illegal = `FALSE;
		if(valid_inst_in) begin
			casez (inst) 
				`RV32_LUI: begin
					dest_reg   = DEST_RD;
					opa_select = OPA_IS_ZERO;
					opb_select = OPB_IS_U_IMM;
				end
				`RV32_AUIPC: begin
					dest_reg   = DEST_RD;
					opa_select = OPA_IS_PC;
					opb_select = OPB_IS_U_IMM;
				end
				`RV32_JAL: begin
					dest_reg      = DEST_RD;
					opa_select    = OPA_IS_PC;
					opb_select    = OPB_IS_J_IMM;
					uncond_branch = `TRUE;
				end
				`RV32_JALR: begin
					dest_reg      = DEST_RD;
					opa_select    = OPA_IS_RS1;
					opb_select    = OPB_IS_I_IMM;
					uncond_branch = `TRUE;
				end
				`RV32_BEQ, `RV32_BNE, `RV32_BLT, `RV32_BGE,
				`RV32_BLTU, `RV32_BGEU: begin
					opa_select  = OPA_IS_PC;
					opb_select  = OPB_IS_B_IMM;
					cond_branch = `TRUE;
				end
				`RV32_LB, `RV32_LH, `RV32_LW,
				`RV32_LBU, `RV32_LHU: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					rd_mem     = `TRUE;
				end
				`RV32_SB, `RV32_SH, `RV32_SW: begin
					opb_select = OPB_IS_S_IMM;
					wr_mem     = `TRUE;
				end
				`RV32_ADDI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
				end
				`RV32_SLTI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_SLT;
				end
				`RV32_SLTIU: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_SLTU;
				end
				`RV32_ANDI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_AND;
				end
				`RV32_ORI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_OR;
				end
				`RV32_XORI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_XOR;
				end
				`RV32_SLLI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_SLL;
				end
				`RV32_SRLI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_SRL;
				end
				`RV32_SRAI: begin
					dest_reg   = DEST_RD;
					opb_select = OPB_IS_I_IMM;
					alu_func   = ALU_SRA;
				end
				`RV32_ADD: begin
					dest_reg   = DEST_RD;
				end
				`RV32_SUB: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SUB;
				end
				`RV32_SLT: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SLT;
				end
				`RV32_SLTU: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SLTU;
				end
				`RV32_AND: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_AND;
				end
				`RV32_OR: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_OR;
				end
				`RV32_XOR: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_XOR;
				end
				`RV32_SLL: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SLL;
				end
				`RV32_SRL: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SRL;
				end
				`RV32_SRA: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_SRA;
				end
				`RV32_MUL: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_MUL;
				end
				`RV32_MULH: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_MULH;
				end
				`RV32_MULHSU: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_MULHSU;
				end
				`RV32_MULHU: begin
					dest_reg   = DEST_RD;
					alu_func   = ALU_MULHU;
				end
				`RV32_CSRRW, `RV32_CSRRS, `RV32_CSRRC: begin
					csr_op = `TRUE;
				end
				`WFI: begin
					halt = `TRUE;
				end
				default: illegal = `TRUE;

		endcase // casez (inst)
		end // if(valid_inst_in)
	end // always
endmodule // decoder


module id_stage(         
	input         clock,              // system clock
	input         reset,              // system reset
	// input         wb_reg_wr_en_out,    // Reg write enable from WB Stage
	// input  [4:0] wb_reg_wr_idx_out,  // Reg write index from WB Stage
	// input  [`XLEN-1:0] wb_reg_wr_data_out,  // Reg write data from WB Stage
	input  IF_ID_PACKET if_id_packet_in,
	
	output ID_EX_PACKET id_packet_out
);

    assign id_packet_out.inst = if_id_packet_in.inst;
    assign id_packet_out.NPC  = if_id_packet_in.NPC;
    assign id_packet_out.PC   = if_id_packet_in.PC;
	DEST_REG_SEL dest_reg_select; 

	// Instantiate the register file used by this pipeline
	// regfile regf_0 (
	// 	.rda_idx(if_id_packet_in.inst.r.rs1),
	// 	.rda_out(id_packet_out.rs1_value), 

	// 	.rdb_idx(if_id_packet_in.inst.r.rs2),
	// 	.rdb_out(id_packet_out.rs2_value),

	// 	.wr_clk(clock),
	// 	.wr_en(wb_reg_wr_en_out),
	// 	.wr_idx(wb_reg_wr_idx_out),
	// 	.wr_data(wb_reg_wr_data_out)
	// );

	// instantiate the instruction decoder
	decoder decoder_0 (
		.if_packet(if_id_packet_in),	 
		// Outputs
		.opa_select(id_packet_out.opa_select),
		.opb_select(id_packet_out.opb_select),
		.alu_func(id_packet_out.alu_func),
		.dest_reg(dest_reg_select),
		.rd_mem(id_packet_out.rd_mem),
		.wr_mem(id_packet_out.wr_mem),
		.cond_branch(id_packet_out.cond_branch),
		.uncond_branch(id_packet_out.uncond_branch),
		.csr_op(id_packet_out.csr_op),
		.halt(id_packet_out.halt),
		.illegal(id_packet_out.illegal),
		.valid_inst(id_packet_out.valid)
	);

	// mux to generate dest_reg_idx based on
	// the dest_reg_select output from decoder
	always_comb begin
		case (dest_reg_select)
			DEST_RD:    id_packet_out.dest_reg_idx = if_id_packet_in.inst.r.rd;
			DEST_NONE:  id_packet_out.dest_reg_idx = `ZERO_REG;
			default:    id_packet_out.dest_reg_idx = `ZERO_REG; 
		endcase


		id_packet_out.req_reg[0] = 1'b0;
		casez (if_id_packet_in.inst) 
			`RV32_LUI, `RV32_AUIPC, `RV32_JAL: begin
				id_packet_out.req_reg[0] = 1'b0;
			end
			default: 
				id_packet_out.req_reg[0] = 1'b1;
		endcase

		id_packet_out.req_reg[1] = 1'b0;
		if (if_id_packet.valid) begin
			casez (if_id_packet.inst) 
				`RV32_LUI, `RV32_AUIPC, `RV32_JAL, `RV32_JALR, `RV32_LB, `RV32_LH, 
				`RV32_LW, `RV32_LBU, `RV32_LHU, `RV32_ADDI, `RV32_SLTI, `RV32_SLTIU, `RV32_ANDI, 
				`RV32_ORI, `RV32_XORI, `RV32_SLLI, `RV32_SRLI, `RV32_SRAI: begin
					id_packet_out.req_reg[1] = 1'b0;
				end
				default: 
					id_packet_out.req_reg[1] = 1'b1;
			endcase
		end

	end
   
endmodule // module id_stage
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  if_stage.v                                          //
//                                                                     //
//  Description :  instruction fetch (IF) stage of the pipeline;       // 
//                 fetch instruction, compute next PC location, and    //
//                 send them down the pipeline.                        //
//                                                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

`timescale 1ns/100ps

module if_stage(
	input         clock,                  // system clock
	input         reset,                  // system reset
	// input         mem_wb_valid_inst,      // only go to next instruction when true
	//                                       // makes pipeline behave as single-cycle
	input 		  stall,
	input         ex_mem_take_branch,      // taken-branch signal
	input  [`XLEN-1:0] ex_mem_target_pc,        // target pc: use if take_branch is TRUE
	input  [63:0] Imem2proc_data,          // Data coming back from instruction-memory
	output logic [`XLEN-1:0] proc2Imem_addr,    // Address sent to Instruction memory
	output IF_ID_PACKET if_packet_out         // Output data packet from IF going to ID, see sys_defs for signal information 
);


	logic    [`XLEN-1:0] PC_reg;             // PC we are currently fetching
	
	logic    [`XLEN-1:0] PC_plus_4;
	logic    [`XLEN-1:0] next_PC;
	logic           PC_enable;
	
	assign proc2Imem_addr = {PC_reg[`XLEN-1:3], 3'b0};
	
	// this mux is because the Imem gives us 64 bits not 32 bits
	assign if_packet_out.inst = PC_reg[2] ? Imem2proc_data[63:32] : Imem2proc_data[31:0];
	
	// default next PC value
	assign PC_plus_4 = PC_reg + 4;
	
	// next PC is target_pc if there is a taken branch or
	// the next sequential PC (PC+4) if no branch
	// (halting is handled with the enable PC_enable;
	assign next_PC = ex_mem_take_branch ? ex_mem_target_pc : PC_plus_4;
	
	// The take-branch signal must override stalling (otherwise it may be lost)
	assign PC_enable = if_packet_out.valid | ex_mem_take_branch;
	
	// Pass PC+4 down pipeline w/instruction
	assign if_packet_out.NPC = PC_plus_4;
	assign if_packet_out.PC  = PC_reg;
	// This register holds the PC value
	// synopsys sync_set_reset "reset"
	always_ff @(posedge clock) begin
		if(reset)
			PC_reg <= `SD 0;       // initial PC value is 0
		else if(PC_enable)
			PC_reg <= `SD next_PC; // transition to next PC
	end  // always
	
	// This FF controls the stall signal that artificially forces
	// fetch to stall until the previous instruction has completed
	// This must be removed for Project 3
	// synopsys sync_set_reset "reset"
	// always_ff @(posedge clock) begin
	// 	if (reset)
	// 		if_packet_out.valid <= `SD 1;  // must start with something
	// 	else
	// 		if_packet_out.valid <= `SD mem_wb_valid_inst;
	// end
	assign if_packet_out.valid = !stall;
endmodule  // module if_stage
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  mem_stage.v                                         //
//                                                                     //
//  Description :  memory access (MEM) stage of the pipeline;          //
//                 this stage accesses memory for stores and loads,    // 
//                 and selects the proper next PC value for branches   // 
//                 based on the branch condition computed in the       //
//                 previous stage.                                     // 
//                                                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

`ifndef __MEM_STAGE_V__
`define __MEM_STAGE_V__

`timescale 1ns/100ps

module mem_stage(
	input         clock,              // system clock
	input         reset,              // system reset
	input  EX_MEM_PACKET ex_mem_packet_in,      // write memory? (from decoder)
	input  [`XLEN-1:0] Dmem2proc_data,
	
	output logic [`XLEN-1:0] mem_result_out,      // outgoing instruction result (to MEM/WB)
	output logic [1:0] proc2Dmem_command,
	output MEM_SIZE proc2Dmem_size,
	output logic [`XLEN-1:0] proc2Dmem_addr,      // Address sent to data-memory
	output logic [`XLEN-1:0] proc2Dmem_data      // Data sent to data-memory
);



	// Determine the command that must be sent to mem
	assign proc2Dmem_command =
	                        (ex_mem_packet_in.wr_mem & ex_mem_packet_in.valid) ? BUS_STORE :
							(ex_mem_packet_in.rd_mem & ex_mem_packet_in.valid) ? BUS_LOAD :
	                        BUS_NONE;

	assign proc2Dmem_size = MEM_SIZE'(ex_mem_packet_in.mem_size[1:0]);	//only the 2 LSB to determine the size;
	


	// The memory address is calculated by the ALU
	assign proc2Dmem_data = ex_mem_packet_in.rs2_value;

	assign proc2Dmem_addr = ex_mem_packet_in.alu_result;	
	// Assign the result-out for next stage
	always_comb begin
		mem_result_out = ex_mem_packet_in.alu_result;
		if (ex_mem_packet_in.rd_mem) begin
			if (~ex_mem_packet_in.mem_size[2]) begin //is this an signed/unsigned load?
				if (ex_mem_packet_in.mem_size[1:0] == 2'b0)
					mem_result_out = {{(`XLEN-8){Dmem2proc_data[7]}}, Dmem2proc_data[7:0]};
				else if  (ex_mem_packet_in.mem_size[1:0] == 2'b01) 
					mem_result_out = {{(`XLEN-16){Dmem2proc_data[15]}}, Dmem2proc_data[15:0]};
				else mem_result_out = Dmem2proc_data;
			end else begin
				if (ex_mem_packet_in.mem_size[1:0] == 2'b0)
					mem_result_out = {{(`XLEN-8){1'b0}}, Dmem2proc_data[7:0]};
				else if  (ex_mem_packet_in.mem_size[1:0] == 2'b01)
					mem_result_out = {{(`XLEN-16){1'b0}}, Dmem2proc_data[15:0]};
				else mem_result_out = Dmem2proc_data;
			end
		end
	end
	//if we are in 32 bit mode, then we should never load a double word sized data
	assert property (@(negedge clock) (`XLEN == 32) && ex_mem_packet_in.rd_mem |-> proc2Dmem_size != DOUBLE);

endmodule // module mem_stage
`endif // __MEM_STAGE_V__
`ifndef __MULT_SV__
`define __MULT_SV__
`timescale 1ns/100ps

module mult #(parameter XLEN = 32, parameter NUM_STAGE = 4) (
				input clock, reset,
				input start,
				input [1:0] sign,
				input [XLEN-1:0] mcand, mplier,
				
				output [(2*XLEN)-1:0] product,
				output done
			);
	logic [(2*XLEN)-1:0] mcand_out, mplier_out, mcand_in, mplier_in;
  	logic [(NUM_STAGE-1)*(2*XLEN)-1:0] internal_products, internal_mcands, internal_mpliers;
  	logic [(NUM_STAGE-2):0] internal_dones;

	assign mcand_in  = sign[0] ? {{XLEN{mcand[XLEN-1]}}, mcand}   : {{XLEN{1'b0}}, mcand} ;
	assign mplier_in = sign[1] ? {{XLEN{mplier[XLEN-1]}}, mplier} : {{XLEN{1'b0}}, mplier};

	mult_stage #(.XLEN(XLEN), .NUM_STAGE(NUM_STAGE)) mstage [NUM_STAGE-1:0]  (
		.clock(clock),
		.reset(reset),
		.product_in({internal_products,64'h0}),
		.mplier_in({internal_mpliers,mplier_in}),
		.mcand_in({internal_mcands,mcand_in}),
		.start({internal_dones,start}),
		.product_out({product,internal_products}),
		.mplier_out({mplier_out,internal_mpliers}),
		.mcand_out({mcand_out,internal_mcands}),
		.done({done,internal_dones})
	);

endmodule

module mult_stage #(parameter XLEN = 32, parameter NUM_STAGE = 4) (
					input clock, reset, start,
					input [(2*XLEN)-1:0] mplier_in, mcand_in,
					input [(2*XLEN)-1:0] product_in,

					output logic done,
					output logic [(2*XLEN)-1:0] mplier_out, mcand_out,
					output logic [(2*XLEN)-1:0] product_out
				);

	parameter NUM_BITS = (2*XLEN)/NUM_STAGE;

	logic [(2*XLEN)-1:0] prod_in_reg, partial_prod, next_partial_product, partial_prod_unsigned;
	logic [(2*XLEN)-1:0] next_mplier, next_mcand;

	assign product_out = prod_in_reg + partial_prod;

	assign next_partial_product = mplier_in[(NUM_BITS-1):0] * mcand_in;

	assign next_mplier = {{(NUM_BITS){1'b0}},mplier_in[2*XLEN-1:(NUM_BITS)]};
	assign next_mcand  = {mcand_in[(2*XLEN-1-NUM_BITS):0],{(NUM_BITS){1'b0}}};

	//synopsys sync_set_reset "reset"
	always_ff @(posedge clock) begin
		prod_in_reg      <= `SD product_in;
		partial_prod     <= `SD next_partial_product;
		mplier_out       <= `SD next_mplier;
		mcand_out        <= `SD next_mcand;
	end

	// synopsys sync_set_reset "reset"
	always_ff @(posedge clock) begin
		if(reset) begin
			done     <= `SD 1'b0;
		end else begin
			done     <= `SD start;
		end
	end

endmodule
`endif //__MULT_SV__
/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  wb_stage.v                                          //
//                                                                     //
//  Description :   writeback (WB) stage of the pipeline;              //
//                  determine the destination register of the          //
//                  instruction and write the result to the register   //
//                  file (if not to the zero register), also reset the //
//                  NPC in the fetch stage to the correct next PC      //
//                  address.                                           // 
//                                                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

`timescale 1ns/100ps


module wb_stage(
    input         clock,                // system clock
    input         reset,                // system reset
    input  [`XLEN-1:0] mem_wb_NPC,            // incoming instruction PC+4
    input  [`XLEN-1:0] mem_wb_result,        // incoming instruction result
    input         mem_wb_take_branch, 
    input   [4:0] mem_wb_dest_reg_idx,  // dest index (ZERO_REG if no writeback)
    input         mem_wb_valid_inst,

    output logic [`XLEN-1:0] reg_wr_data_out,      // register writeback data
    output logic [4:0] reg_wr_idx_out,        // register writeback index
    output logic       reg_wr_en_out          // register writeback enable
    // Always enabled if valid inst
  );


  wire   [`XLEN-1:0] result_mux;

  // Mux to select register writeback data:
  // ALU/MEM result, unless taken branch, in which case we write
  // back the old NPC as the return address.  Note that ALL branches
  // and jumps write back the 'link' value, but those that don't
  // want it specify ZERO_REG as the destination.
  assign result_mux = (mem_wb_take_branch) ? mem_wb_NPC : mem_wb_result;

  // Generate signals for write-back to register file
  // reg_wr_en_out computation is sort of overkill since the reg file
  // has a special way of handling `ZERO_REG but there is no harm 
  // in putting this here.  Hopefully it illustrates how the pipeline works.
  assign reg_wr_en_out  = mem_wb_dest_reg_idx != `ZERO_REG;
  assign reg_wr_idx_out = mem_wb_dest_reg_idx;
  assign reg_wr_data_out = result_mux;

endmodule // module wb_stage

